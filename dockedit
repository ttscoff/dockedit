#!/usr/bin/env ruby
# frozen_string_literal: true

# dockedit - A script to edit the macOS Dock
# Usage: dockedit <subcommand> [options] [args]

require 'rexml/document'
require 'fileutils'
require 'optparse'

DOCK_PLIST = File.expand_path('~/Library/Preferences/com.apple.dock.plist')

# Calculate match score (lower is better, nil means no match)
def match_score(query, target)
  return nil if target.nil? || target.empty?

  query = query.downcase
  target = target.downcase

  # Exact match - best score
  return 0 if target == query

  # Starts with query
  return 1 if target.start_with?(query)

  # Contains match - score based on position
  if target.include?(query)
    return 2 + target.index(query)
  end

  # Abbreviation match (e.g., "vscode" matches "Visual Studio Code")
  query_chars = query.chars
  target_pos = 0
  matched = true

  query_chars.each do |char|
    found = false
    while target_pos < target.length
      if target[target_pos] == char
        found = true
        target_pos += 1
        break
      end
      target_pos += 1
    end
    unless found
      matched = false
      break
    end
  end

  return 100 + target.length if matched

  nil
end

# Fuzzy matching for app names
def fuzzy_match?(query, target)
  !match_score(query, target).nil?
end

# Find app index in persistent-apps array (returns best match - shortest name wins on tie)
def find_app_index(apps_array, query)
  best_match = nil
  best_score = nil
  best_name = nil
  best_index = nil

  apps_array.each_with_index do |app_dict, index|
    next unless app_dict.is_a?(REXML::Element) && app_dict.name == 'dict'

    tile_data = get_tile_data(app_dict)
    next unless tile_data

    file_label = get_tile_value(tile_data, 'file-label')
    bundle_id = get_tile_value(tile_data, 'bundle-identifier')

    label_score = match_score(query, file_label)
    bundle_score = match_score(query, bundle_id)

    # Use the better of the two scores
    current_score = [label_score, bundle_score].compact.min
    next unless current_score

    name = file_label || bundle_id
    name_length = name&.length || 999

    # Prefer lower score, then shorter name
    if best_score.nil? || current_score < best_score ||
       (current_score == best_score && name_length < (best_name&.length || 999))
      best_score = current_score
      best_name = name
      best_index = index
    end
  end

  [best_index, best_name]
end

# Get tile-data dict from app dict
def get_tile_data(app_dict)
  current_key = nil
  app_dict.elements.each do |elem|
    if elem.name == 'key'
      current_key = elem.text
    elsif elem.name == 'dict' && current_key == 'tile-data'
      return elem
    end
  end
  nil
end

# Get a string value from tile-data
def get_tile_value(tile_data, key_name)
  current_key = nil
  tile_data.elements.each do |elem|
    if elem.name == 'key'
      current_key = elem.text
    elsif current_key == key_name
      return elem.text if elem.name == 'string'
      return nil
    end
  end
  nil
end

# Create a spacer tile element
def create_spacer_tile(small: false)
  tile_type = small ? 'small-spacer-tile' : 'spacer-tile'

  spacer = REXML::Element.new('dict')

  key1 = REXML::Element.new('key')
  key1.text = 'tile-data'
  spacer.add(key1)

  tile_data = REXML::Element.new('dict')
  label_key = REXML::Element.new('key')
  label_key.text = 'file-label'
  tile_data.add(label_key)
  label_string = REXML::Element.new('string')
  label_string.text = ''
  tile_data.add(label_string)
  spacer.add(tile_data)

  key2 = REXML::Element.new('key')
  key2.text = 'tile-type'
  spacer.add(key2)

  type_string = REXML::Element.new('string')
  type_string.text = tile_type
  spacer.add(type_string)

  spacer
end

# Get the persistent-apps array from the plist
def get_persistent_apps(doc)
  root_dict = doc.root.elements['dict']
  return nil unless root_dict

  current_key = nil
  root_dict.elements.each do |elem|
    if elem.name == 'key'
      current_key = elem.text
    elsif elem.name == 'array' && current_key == 'persistent-apps'
      return elem
    end
  end

  nil
end

# Find app on disk using mdfind
def find_app_on_disk(query)
  # Search in /Applications and /System/Applications
  result = `mdfind -onlyin /Applications -onlyin /System/Applications 'kMDItemKind == "Application" && kMDItemDisplayName == "*#{query}*"cd' 2>/dev/null`.strip

  if result.empty?
    # Fallback to filename search
    result = `mdfind -onlyin /Applications -onlyin /System/Applications 'kMDItemFSName == "*#{query}*.app"cd' 2>/dev/null`.strip
  end

  return nil if result.empty?

  apps = result.split("\n").select { |p| p.end_with?('.app') }
  return nil if apps.empty?

  # Score and sort by best match (shortest name wins on equal score)
  scored = apps.map do |path|
    name = File.basename(path, '.app')
    score = match_score(query, name)
    [path, name, score || 999, name.length]
  end

  # Sort by score, then by name length
  scored.sort_by! { |_, _, score, len| [score, len] }

  scored.first&.first
end

# Read Info.plist from an app bundle
def read_app_info(app_path)
  info_plist = File.join(app_path, 'Contents', 'Info.plist')
  return nil unless File.exist?(info_plist)

  # Convert to XML and read
  temp_plist = "/tmp/dockedit_info_#{$$}.plist"
  FileUtils.cp(info_plist, temp_plist)
  system("plutil -convert xml1 '#{temp_plist}' 2>/dev/null")

  content = File.read(temp_plist)
  File.delete(temp_plist) if File.exist?(temp_plist)

  doc = REXML::Document.new(content)
  root_dict = doc.root.elements['dict']
  return nil unless root_dict

  info = {}
  current_key = nil

  root_dict.elements.each do |elem|
    if elem.name == 'key'
      current_key = elem.text
    elsif current_key
      case elem.name
      when 'string'
        info[current_key] = elem.text
      when 'array'
        # For arrays, get first string element
        first_string = elem.elements['string']
        info[current_key] = first_string.text if first_string
      end
      current_key = nil
    end
  end

  info
end

# Create an app tile element
def create_app_tile(app_path, app_info)
  app_dict = REXML::Element.new('dict')

  # tile-data key
  td_key = REXML::Element.new('key')
  td_key.text = 'tile-data'
  app_dict.add(td_key)

  # tile-data dict
  tile_data = REXML::Element.new('dict')

  # bundle-identifier
  add_plist_key_value(tile_data, 'bundle-identifier', 'string', app_info['CFBundleIdentifier'])

  # dock-extra
  add_plist_key_value(tile_data, 'dock-extra', 'false', nil)

  # file-data dict
  fd_key = REXML::Element.new('key')
  fd_key.text = 'file-data'
  tile_data.add(fd_key)

  file_data = REXML::Element.new('dict')
  add_plist_key_value(file_data, '_CFURLString', 'string', "file://#{app_path}/")
  add_plist_key_value(file_data, '_CFURLStringType', 'integer', '15')
  tile_data.add(file_data)

  # file-label
  label = app_info['CFBundleName'] || app_info['CFBundleDisplayName'] || File.basename(app_path, '.app')
  add_plist_key_value(tile_data, 'file-label', 'string', label)

  # file-mod-date
  add_plist_key_value(tile_data, 'file-mod-date', 'integer', '0')

  # file-type
  add_plist_key_value(tile_data, 'file-type', 'integer', '41')

  # is-beta
  add_plist_key_value(tile_data, 'is-beta', 'false', nil)

  # parent-mod-date
  add_plist_key_value(tile_data, 'parent-mod-date', 'integer', '0')

  app_dict.add(tile_data)

  # tile-type key
  tt_key = REXML::Element.new('key')
  tt_key.text = 'tile-type'
  app_dict.add(tt_key)

  tt_value = REXML::Element.new('string')
  tt_value.text = 'file-tile'
  app_dict.add(tt_value)

  app_dict
end

# Helper to add key/value pair to plist dict
def add_plist_key_value(dict, key_name, value_type, value)
  key = REXML::Element.new('key')
  key.text = key_name
  dict.add(key)

  val_elem = REXML::Element.new(value_type)
  val_elem.text = value if value
  dict.add(val_elem)
end

# Write plist and restart dock
def write_plist_and_restart(doc, success_messages)
  formatter = REXML::Formatters::Pretty.new(2)
  formatter.compact = true

  output = StringIO.new
  output << %{<?xml version="1.0" encoding="UTF-8"?>\n}
  output << %{<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n}
  formatter.write(doc.root, output)
  output << "\n"

  begin
    File.write(DOCK_PLIST, output.string)
  rescue => e
    $stderr.puts "Error: Failure to update Dock plist - #{e.message}"
    exit 1
  end

  # Convert back to binary and restart Dock
  unless system("plutil -convert binary1 '#{DOCK_PLIST}' 2>/dev/null")
    $stderr.puts "Error: Failure to update Dock plist"
    exit 1
  end

  system('killall Dock')

  # Handle single message or array of messages
  messages = success_messages.is_a?(Array) ? success_messages : [success_messages]
  messages.each { |msg| puts msg }
  exit 0
end

# Load and parse dock plist
def load_dock_plist
  unless system("plutil -convert xml1 '#{DOCK_PLIST}' 2>/dev/null")
    $stderr.puts "Error: Failed to convert Dock plist to XML"
    exit 1
  end

  plist_content = File.read(DOCK_PLIST)
  REXML::Document.new(plist_content)
end

# Insert space subcommand
def cmd_space(args)
  options = { small: false, after: [] }

  parser = OptionParser.new do |opts|
    opts.banner = "Usage: dockedit space [options]"
    opts.on('-s', '--small', '--half', 'Insert a small/half-size space') { options[:small] = true }
    opts.on('-a', '--after APP', 'Insert after specified app (fuzzy match, repeatable)') { |app| options[:after] << app }
  end
  parser.order!(args)

  small = options[:small]
  after_apps = options[:after]
  spacer_type = small ? 'Small space' : 'Space'

  doc = load_dock_plist

  apps_array = get_persistent_apps(doc)
  unless apps_array
    $stderr.puts "Error: Could not find persistent-apps in Dock plist"
    exit 1
  end

  messages = []

  if after_apps.empty?
    # Add single space at end
    spacer = create_spacer_tile(small: small)
    apps_array.add(spacer)
    messages << "#{spacer_type} added to end of Dock."
  else
    # Process each --after app
    after_apps.each do |after_app|
      # Re-fetch app_dicts each time since array changes after insert
      app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }

      index, name = find_app_index(app_dicts, after_app)
      unless index
        $stderr.puts "Error: App '#{after_app}' not found in Dock"
        exit 1
      end

      spacer = create_spacer_tile(small: small)
      apps_array.insert_after(app_dicts[index], spacer)
      messages << "#{spacer_type} inserted after '#{name}'."
    end
  end

  write_plist_and_restart(doc, messages)
end

# Add app subcommand
def cmd_add(args)
  options = { after: nil }

  parser = OptionParser.new do |opts|
    opts.banner = "Usage: dockedit add [options] <app_name> [app_name...]"
    opts.on('-a', '--after APP', 'Insert after specified app (fuzzy match)') { |app| options[:after] = app }
  end
  parser.order!(args)

  after_app = options[:after]

  if args.empty?
    $stderr.puts parser
    exit 1
  end

  doc = load_dock_plist

  apps_array = get_persistent_apps(doc)
  unless apps_array
    $stderr.puts "Error: Could not find persistent-apps in Dock plist"
    exit 1
  end

  messages = []
  last_inserted_element = nil

  # Find initial insertion point if --after specified
  if after_app
    app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
    after_index, after_name = find_app_index(app_dicts, after_app)
    unless after_index
      $stderr.puts "Error: App '#{after_app}' not found in Dock"
      exit 1
    end
    last_inserted_element = app_dicts[after_index]
  end

  # Process each app argument
  args.each do |app_query|
    # Find the app on disk
    app_path = find_app_on_disk(app_query)
    unless app_path
      $stderr.puts "Error: App '#{app_query}' not found"
      exit 1
    end

    # Read app info
    app_info = read_app_info(app_path)
    unless app_info && app_info['CFBundleIdentifier']
      $stderr.puts "Error: Could not read app info from '#{app_path}'"
      exit 1
    end

    app_name = app_info['CFBundleName'] || app_info['CFBundleDisplayName'] || File.basename(app_path, '.app')

    # Check if app is already in dock
    app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
    existing_index, existing_name = find_app_index(app_dicts, app_info['CFBundleIdentifier'])

    if existing_index
      $stderr.puts "Warning: '#{existing_name}' is already in the Dock, skipping"
      next
    end

    # Create the app tile
    app_tile = create_app_tile(app_path, app_info)

    if last_inserted_element
      # Insert after the last inserted element (maintains order)
      apps_array.insert_after(last_inserted_element, app_tile)
      messages << "'#{app_name}' added to Dock."
      last_inserted_element = app_tile
    else
      # Add at end
      apps_array.add(app_tile)
      messages << "'#{app_name}' added to Dock."
    end
  end

  if messages.empty?
    $stderr.puts "No apps were added to the Dock"
    exit 1
  end

  write_plist_and_restart(doc, messages)
end

# Remove app subcommand
def cmd_remove(args)
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: dockedit remove <app_name> [app_name...]"
  end
  parser.order!(args)

  if args.empty?
    $stderr.puts parser
    exit 1
  end

  doc = load_dock_plist

  apps_array = get_persistent_apps(doc)
  unless apps_array
    $stderr.puts "Error: Could not find persistent-apps in Dock plist"
    exit 1
  end

  messages = []

  # Process each app argument
  args.each do |app_query|
    # Re-fetch app_dicts each time since array changes after delete
    app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }

    # Find the app
    index, name = find_app_index(app_dicts, app_query)

    unless index
      $stderr.puts "Warning: App '#{app_query}' not found in Dock, skipping"
      next
    end

    # Remove the app from the array
    apps_array.delete(app_dicts[index])
    messages << "'#{name}' removed from Dock."
  end

  if messages.empty?
    $stderr.puts "No apps were removed from the Dock"
    exit 1
  end

  write_plist_and_restart(doc, messages)
end

# Main entry point
def main
  global_parser = OptionParser.new do |opts|
    opts.banner = "Usage: dockedit <subcommand> [options] [args]"
    opts.separator ""
    opts.separator "Subcommands:"
    opts.separator "  add [-a|--after <app>] <app>...        Add app(s) to the Dock"
    opts.separator "  remove <app>...                        Remove app(s) from the Dock"
    opts.separator "  space [-s|--small] [-a|--after <app>]  Insert space(s) in the Dock"
    opts.separator ""
    opts.separator "Options:"
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  if ARGV.empty?
    puts global_parser
    exit 0
  end

  subcommand = ARGV.shift

  case subcommand
  when 'add'
    cmd_add(ARGV)
  when 'remove'
    cmd_remove(ARGV)
  when 'space'
    cmd_space(ARGV)
  when '-h', '--help'
    puts global_parser
    exit 0
  else
    $stderr.puts "Unknown subcommand: #{subcommand}"
    $stderr.puts "Run 'dockedit --help' for usage"
    exit 1
  end
end

main
