#!/usr/bin/env ruby
# frozen_string_literal: true

# dockedit - A script to edit the macOS Dock
# Usage: dockedit <subcommand> [options] [args]

require 'rexml/document'
require 'fileutils'
require 'optparse'
require 'uri'

DOCK_PLIST = File.expand_path('~/Library/Preferences/com.apple.dock.plist')

# Path shortcuts for folders
PATH_SHORTCUTS = {
  /^desktop$/i => File.expand_path('~/Desktop'),
  /^downloads$/i => File.expand_path('~/Downloads'),
  /^(home|~)$/i => File.expand_path('~'),
  /^library$/i => File.expand_path('~/Library'),
  /^documents$/i => File.expand_path('~/Documents'),
  /^(applications|apps)$/i => '/Applications',
  /^sites$/i => File.expand_path('~/Sites')
}.freeze

# Show-as values for folder display
SHOW_AS_VALUES = {
  'f' => 1, 'fan' => 1,
  'g' => 2, 'grid' => 2,
  'l' => 3, 'list' => 3,
  'a' => 4, 'auto' => 4
}.freeze

# Display-as values for folder appearance
DISPLAY_AS_VALUES = {
  's' => 0, 'stack' => 0,
  'f' => 1, 'folder' => 1
}.freeze

# Calculate match score (lower is better, nil means no match)
def match_score(query, target)
  return nil if target.nil? || target.empty?

  query = query.downcase
  target = target.downcase

  # Exact match - best score
  return 0 if target == query

  # Starts with query
  return 1 if target.start_with?(query)

  # Contains match - score based on position
  if target.include?(query)
    return 2 + target.index(query)
  end

  # Abbreviation match (e.g., "vscode" matches "Visual Studio Code")
  query_chars = query.chars
  target_pos = 0
  matched = true

  query_chars.each do |char|
    found = false
    while target_pos < target.length
      if target[target_pos] == char
        found = true
        target_pos += 1
        break
      end
      target_pos += 1
    end
    unless found
      matched = false
      break
    end
  end

  return 100 + target.length if matched

  nil
end

# Fuzzy matching for app names
def fuzzy_match?(query, target)
  !match_score(query, target).nil?
end

# Find item index in a dock array (persistent-apps or persistent-others)
# For folders, also checks file-data._CFURLString
def find_item_index(items_array, query, check_url: false)
  best_score = nil
  best_name = nil
  best_index = nil

  items_array.each_with_index do |item_dict, index|
    next unless item_dict.is_a?(REXML::Element) && item_dict.name == 'dict'

    tile_data = get_tile_data(item_dict)
    next unless tile_data

    file_label = get_tile_value(tile_data, 'file-label')
    bundle_id = get_tile_value(tile_data, 'bundle-identifier')

    scores = []
    scores << match_score(query, file_label)
    scores << match_score(query, bundle_id)

    # For folders, also check URL path
    if check_url
      url_string = get_file_data_url(tile_data)
      if url_string
        # Extract path from file:// URL and decode
        path = URI.decode_www_form_component(url_string.sub(%r{^file://}, '').chomp('/'))
        basename = File.basename(path)
        scores << match_score(query, path)
        scores << match_score(query, basename)
      end
    end

    current_score = scores.compact.min
    next unless current_score

    name = file_label || bundle_id || 'Unknown'
    name_length = name.length

    if best_score.nil? || current_score < best_score ||
       (current_score == best_score && name_length < (best_name&.length || 999))
      best_score = current_score
      best_name = name
      best_index = index
    end
  end

  [best_index, best_name]
end

# Alias for backward compatibility
def find_app_index(apps_array, query)
  find_item_index(apps_array, query, check_url: false)
end

# Get tile-data dict from app dict
def get_tile_data(app_dict)
  current_key = nil
  app_dict.elements.each do |elem|
    if elem.name == 'key'
      current_key = elem.text
    elsif elem.name == 'dict' && current_key == 'tile-data'
      return elem
    end
  end
  nil
end

# Get a string value from tile-data
def get_tile_value(tile_data, key_name)
  current_key = nil
  tile_data.elements.each do |elem|
    if elem.name == 'key'
      current_key = elem.text
    elsif current_key == key_name
      return elem.text if elem.name == 'string'
      return nil
    end
  end
  nil
end

# Get _CFURLString from file-data dict
def get_file_data_url(tile_data)
  current_key = nil
  tile_data.elements.each do |elem|
    if elem.name == 'key'
      current_key = elem.text
    elsif elem.name == 'dict' && current_key == 'file-data'
      return get_tile_value(elem, '_CFURLString')
    end
  end
  nil
end

# Create a spacer tile element
def create_spacer_tile(small: false)
  tile_type = small ? 'small-spacer-tile' : 'spacer-tile'

  spacer = REXML::Element.new('dict')

  key1 = REXML::Element.new('key')
  key1.text = 'tile-data'
  spacer.add(key1)

  tile_data = REXML::Element.new('dict')
  label_key = REXML::Element.new('key')
  label_key.text = 'file-label'
  tile_data.add(label_key)
  label_string = REXML::Element.new('string')
  label_string.text = ''
  tile_data.add(label_string)
  spacer.add(tile_data)

  key2 = REXML::Element.new('key')
  key2.text = 'tile-type'
  spacer.add(key2)

  type_string = REXML::Element.new('string')
  type_string.text = tile_type
  spacer.add(type_string)

  spacer
end

# Get the persistent-apps array from the plist
def get_persistent_apps(doc)
  get_plist_array(doc, 'persistent-apps')
end

# Get the persistent-others array from the plist
def get_persistent_others(doc)
  get_plist_array(doc, 'persistent-others')
end

# Get a named array from the plist root dict
def get_plist_array(doc, array_name)
  root_dict = doc.root.elements['dict']
  return nil unless root_dict

  current_key = nil
  root_dict.elements.each do |elem|
    if elem.name == 'key'
      current_key = elem.text
    elsif elem.name == 'array' && current_key == array_name
      return elem
    end
  end

  nil
end

# Expand path shortcuts
def expand_path_shortcut(path)
  PATH_SHORTCUTS.each do |pattern, expanded|
    return expanded if path.match?(pattern)
  end
  # Not a shortcut, expand ~ and return
  File.expand_path(path).chomp('/')
end

# Check if path is a folder (not an app)
def folder_path?(path)
  expanded = expand_path_shortcut(path)
  File.directory?(expanded) && !expanded.end_with?('.app')
end

# Check if path is an explicit app path
def explicit_app_path?(path)
  path.end_with?('.app') && path.include?('/')
end

# Find app on disk using mdfind
def find_app_on_disk(query)
  # Search in /Applications and /System/Applications
  result = `mdfind -onlyin /Applications -onlyin /System/Applications 'kMDItemKind == "Application" && kMDItemDisplayName == "*#{query}*"cd' 2>/dev/null`.strip

  if result.empty?
    # Fallback to filename search
    result = `mdfind -onlyin /Applications -onlyin /System/Applications 'kMDItemFSName == "*#{query}*.app"cd' 2>/dev/null`.strip
  end

  return nil if result.empty?

  apps = result.split("\n").select { |p| p.end_with?('.app') }
  return nil if apps.empty?

  # Score and sort by best match (shortest name wins on equal score)
  scored = apps.map do |path|
    name = File.basename(path, '.app')
    score = match_score(query, name)
    [path, name, score || 999, name.length]
  end

  # Sort by score, then by name length
  scored.sort_by! { |_, _, score, len| [score, len] }

  scored.first&.first
end

# Read Info.plist from an app bundle
def read_app_info(app_path)
  info_plist = File.join(app_path, 'Contents', 'Info.plist')
  return nil unless File.exist?(info_plist)

  # Convert to XML and read
  temp_plist = "/tmp/dockedit_info_#{$$}.plist"
  FileUtils.cp(info_plist, temp_plist)
  system("plutil -convert xml1 '#{temp_plist}' 2>/dev/null")

  content = File.read(temp_plist)
  File.delete(temp_plist) if File.exist?(temp_plist)

  doc = REXML::Document.new(content)
  root_dict = doc.root.elements['dict']
  return nil unless root_dict

  info = {}
  current_key = nil

  root_dict.elements.each do |elem|
    if elem.name == 'key'
      current_key = elem.text
    elsif current_key
      case elem.name
      when 'string'
        info[current_key] = elem.text
      when 'array'
        # For arrays, get first string element
        first_string = elem.elements['string']
        info[current_key] = first_string.text if first_string
      end
      current_key = nil
    end
  end

  info
end

# Create an app tile element
def create_app_tile(app_path, app_info)
  app_dict = REXML::Element.new('dict')

  # tile-data key
  td_key = REXML::Element.new('key')
  td_key.text = 'tile-data'
  app_dict.add(td_key)

  # tile-data dict
  tile_data = REXML::Element.new('dict')

  # bundle-identifier
  add_plist_key_value(tile_data, 'bundle-identifier', 'string', app_info['CFBundleIdentifier'])

  # dock-extra
  add_plist_key_value(tile_data, 'dock-extra', 'false', nil)

  # file-data dict
  fd_key = REXML::Element.new('key')
  fd_key.text = 'file-data'
  tile_data.add(fd_key)

  file_data = REXML::Element.new('dict')
  add_plist_key_value(file_data, '_CFURLString', 'string', "file://#{URI.encode_www_form_component(app_path).gsub('%2F', '/')}/")
  add_plist_key_value(file_data, '_CFURLStringType', 'integer', '15')
  tile_data.add(file_data)

  # file-label
  label = app_info['CFBundleName'] || app_info['CFBundleDisplayName'] || File.basename(app_path, '.app')
  add_plist_key_value(tile_data, 'file-label', 'string', label)

  # file-mod-date
  add_plist_key_value(tile_data, 'file-mod-date', 'integer', '0')

  # file-type
  add_plist_key_value(tile_data, 'file-type', 'integer', '41')

  # is-beta
  add_plist_key_value(tile_data, 'is-beta', 'false', nil)

  # parent-mod-date
  add_plist_key_value(tile_data, 'parent-mod-date', 'integer', '0')

  app_dict.add(tile_data)

  # tile-type key
  tt_key = REXML::Element.new('key')
  tt_key.text = 'tile-type'
  app_dict.add(tt_key)

  tt_value = REXML::Element.new('string')
  tt_value.text = 'file-tile'
  app_dict.add(tt_value)

  app_dict
end

# Create a folder tile element
def create_folder_tile(folder_path, show_as: 4, display_as: 1)
  folder_dict = REXML::Element.new('dict')

  # tile-data key
  td_key = REXML::Element.new('key')
  td_key.text = 'tile-data'
  folder_dict.add(td_key)

  # tile-data dict
  tile_data = REXML::Element.new('dict')

  # arrangement (0 = by name)
  add_plist_key_value(tile_data, 'arrangement', 'integer', '0')

  # displayas (0 = stack, 1 = folder)
  add_plist_key_value(tile_data, 'displayas', 'integer', display_as.to_s)

  # file-data dict
  fd_key = REXML::Element.new('key')
  fd_key.text = 'file-data'
  tile_data.add(fd_key)

  file_data = REXML::Element.new('dict')
  encoded_path = URI.encode_www_form_component(folder_path).gsub('%2F', '/')
  add_plist_key_value(file_data, '_CFURLString', 'string', "file://#{encoded_path}/")
  add_plist_key_value(file_data, '_CFURLStringType', 'integer', '15')
  tile_data.add(file_data)

  # file-label
  label = File.basename(folder_path)
  add_plist_key_value(tile_data, 'file-label', 'string', label)

  # file-mod-date
  add_plist_key_value(tile_data, 'file-mod-date', 'integer', '0')

  # file-type
  add_plist_key_value(tile_data, 'file-type', 'integer', '2')

  # parent-mod-date
  add_plist_key_value(tile_data, 'parent-mod-date', 'integer', '0')

  # preferreditemsize (-1 = default)
  add_plist_key_value(tile_data, 'preferreditemsize', 'integer', '-1')

  # showas (1=fan, 2=grid, 3=list, 4=auto)
  add_plist_key_value(tile_data, 'showas', 'integer', show_as.to_s)

  folder_dict.add(tile_data)

  # tile-type key
  tt_key = REXML::Element.new('key')
  tt_key.text = 'tile-type'
  folder_dict.add(tt_key)

  tt_value = REXML::Element.new('string')
  tt_value.text = 'directory-tile'
  folder_dict.add(tt_value)

  folder_dict
end

# Helper to add key/value pair to plist dict
def add_plist_key_value(dict, key_name, value_type, value)
  key = REXML::Element.new('key')
  key.text = key_name
  dict.add(key)

  val_elem = REXML::Element.new(value_type)
  val_elem.text = value if value
  dict.add(val_elem)
end

# Write plist and restart dock
def write_plist_and_restart(doc, success_messages)
  formatter = REXML::Formatters::Pretty.new(2)
  formatter.compact = true

  output = StringIO.new
  output << %{<?xml version="1.0" encoding="UTF-8"?>\n}
  output << %{<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n}
  formatter.write(doc.root, output)
  output << "\n"

  begin
    File.write(DOCK_PLIST, output.string)
  rescue => e
    $stderr.puts "Error: Failure to update Dock plist - #{e.message}"
    exit 1
  end

  # Convert back to binary and restart Dock
  unless system("plutil -convert binary1 '#{DOCK_PLIST}' 2>/dev/null")
    $stderr.puts "Error: Failure to update Dock plist"
    exit 1
  end

  system('killall Dock')

  # Handle single message or array of messages
  messages = success_messages.is_a?(Array) ? success_messages : [success_messages]
  messages.each { |msg| puts msg }
  exit 0
end

# Load and parse dock plist
def load_dock_plist
  unless system("plutil -convert xml1 '#{DOCK_PLIST}' 2>/dev/null")
    $stderr.puts "Error: Failed to convert Dock plist to XML"
    exit 1
  end

  plist_content = File.read(DOCK_PLIST)
  REXML::Document.new(plist_content)
end

# Parse show-as argument
def parse_show_as(value)
  return nil if value.nil?

  key = value.downcase
  SHOW_AS_VALUES[key] || 4
end

# Get human-readable name for show-as value
def show_as_name(value)
  case value
  when 1 then 'fan'
  when 2 then 'grid'
  when 3 then 'list'
  when 4 then 'auto'
  else 'auto'
  end
end

# Parse display-as argument
def parse_display_as(value)
  return nil if value.nil?

  key = value.downcase
  DISPLAY_AS_VALUES[key]
end

# Get human-readable name for display-as value
def display_as_name(value)
  case value
  when 0 then 'stack'
  when 1 then 'folder'
  else 'stack'
  end
end

# Insert space subcommand
def cmd_space(args)
  options = { small: false, after: [] }

  parser = OptionParser.new do |opts|
    opts.banner = "Usage: dockedit space [options]"
    opts.separator ""
    opts.separator "Examples:"
    opts.separator "  dockedit space"
    opts.separator "  dockedit space --small"
    opts.separator "  dockedit space --after Safari"
    opts.separator "  dockedit space --small --after Terminal --after Safari"
    opts.on('-s', '--small', '--half', 'Insert a small/half-size space') { options[:small] = true }
    opts.on('-a', '--after APP', 'Insert after specified app (fuzzy match, repeatable)') { |app| options[:after] << app }
  end
  parser.order!(args)

  small = options[:small]
  after_apps = options[:after]
  spacer_type = small ? 'Small space' : 'Space'

  doc = load_dock_plist

  apps_array = get_persistent_apps(doc)
  unless apps_array
    $stderr.puts "Error: Could not find persistent-apps in Dock plist"
    exit 1
  end

  messages = []

  if after_apps.empty?
    # Add single space at end
    spacer = create_spacer_tile(small: small)
    apps_array.add(spacer)
    messages << "#{spacer_type} added to end of Dock."
  else
    # Process each --after app
    after_apps.each do |after_app|
      # Re-fetch app_dicts each time since array changes after insert
      app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }

      index, name = find_app_index(app_dicts, after_app)
      unless index
        $stderr.puts "Error: App '#{after_app}' not found in Dock"
        exit 1
      end

      spacer = create_spacer_tile(small: small)
      apps_array.insert_after(app_dicts[index], spacer)
      messages << "#{spacer_type} inserted after '#{name}'."
    end
  end

  write_plist_and_restart(doc, messages)
end

# Update showas value for an existing folder tile
def update_folder_showas(folder_dict, show_as)
  update_folder_integer_key(folder_dict, 'showas', show_as)
end

# Update displayas value for an existing folder tile
def update_folder_displayas(folder_dict, display_as)
  update_folder_integer_key(folder_dict, 'displayas', display_as)
end

# Update an integer key in folder tile-data
def update_folder_integer_key(folder_dict, key_name, value)
  tile_data = get_tile_data(folder_dict)
  return false unless tile_data

  # Find and update the key
  current_key = nil
  tile_data.elements.each do |elem|
    if elem.name == 'key' && elem.text == key_name
      current_key = elem
    elsif current_key && elem.name == 'integer'
      elem.text = value.to_s
      return true
    end
  end

  # If key doesn't exist, add it
  add_plist_key_value(tile_data, key_name, 'integer', value.to_s)
  true
end

# Add app/folder subcommand
def cmd_add(args)
  options = { after: nil, show_as: nil, display_as: nil }

  parser = OptionParser.new do |opts|
    opts.banner = "Usage: dockedit add [options] <app_or_folder> [...]"
    opts.separator ""
    opts.separator "Examples:"
    opts.separator "  dockedit add Safari Terminal"
    opts.separator "  dockedit add ~/Downloads --show grid --display stack"
    opts.separator "  dockedit add Notes --after Safari"
    opts.separator "  dockedit add ~/Sites --display folder --show grid"
    opts.on('-a', '--after ITEM', 'Insert after specified app/folder (fuzzy match)') { |app| options[:after] = app }
    opts.on('--show TYPE', '--view TYPE', 'Folder view: fan/f, grid/g, list/l, auto/a (default: auto)') { |t| options[:show_as] = parse_show_as(t) }
    opts.on('--display TYPE', 'Folder style: folder/f, stack/s (default: folder)') { |t| options[:display_as] = parse_display_as(t) }
  end
  parser.permute!(args)

  after_target = options[:after]
  show_as = options[:show_as]
  display_as = options[:display_as]

  if args.empty?
    $stderr.puts parser
    exit 1
  end

  doc = load_dock_plist

  apps_array = get_persistent_apps(doc)
  others_array = get_persistent_others(doc)

  unless apps_array && others_array
    $stderr.puts "Error: Could not find dock arrays in plist"
    exit 1
  end

  messages = []
  last_inserted_app_element = nil
  last_inserted_folder_element = nil

  # Find initial insertion point if --after specified
  if after_target
    # First check persistent-apps
    app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
    after_index, _after_name = find_app_index(app_dicts, after_target)

    if after_index
      last_inserted_app_element = app_dicts[after_index]
    else
      # Check persistent-others (folders)
      folder_dicts = others_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
      after_index, _after_name = find_item_index(folder_dicts, after_target, check_url: true)

      if after_index
        last_inserted_folder_element = folder_dicts[after_index]
      else
        $stderr.puts "Error: '#{after_target}' not found in Dock"
        exit 1
      end
    end
  end

  # Process each argument
  args.each do |item_query|
    # Determine if this is a folder or app
    if folder_path?(item_query)
      # It's a folder
      folder_path = expand_path_shortcut(item_query)

      unless File.directory?(folder_path)
        $stderr.puts "Error: Folder '#{folder_path}' not found"
        exit 1
      end

      folder_name = File.basename(folder_path)

      # Check if folder is already in dock
      folder_dicts = others_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
      existing_index, existing_name = find_item_index(folder_dicts, folder_path, check_url: true)

      if existing_index
        # If show_as or display_as was specified, update the existing folder
        updates = []
        if show_as
          update_folder_showas(folder_dicts[existing_index], show_as)
          updates << "view=#{show_as_name(show_as)}"
        end
        if display_as
          update_folder_displayas(folder_dicts[existing_index], display_as)
          updates << "style=#{display_as_name(display_as)}"
        end

        if updates.any?
          messages << "'#{existing_name}' updated (#{updates.join(', ')})."
        else
          $stderr.puts "Warning: '#{existing_name}' is already in the Dock, skipping"
        end
        next
      end

      # Create the folder tile (use defaults if not specified)
      folder_tile = create_folder_tile(folder_path, show_as: show_as || 4, display_as: display_as || 1)

      if last_inserted_folder_element
        others_array.insert_after(last_inserted_folder_element, folder_tile)
      else
        others_array.add(folder_tile)
      end

      last_inserted_folder_element = folder_tile
      messages << "'#{folder_name}' folder added to Dock."

    elsif explicit_app_path?(item_query)
      # Explicit app path given
      app_path = File.expand_path(item_query)

      unless File.exist?(File.join(app_path, 'Contents', 'Info.plist'))
        $stderr.puts "Error: Application path '#{app_path}' not found"
        exit 1
      end

      app_info = read_app_info(app_path)
      unless app_info && app_info['CFBundleIdentifier']
        $stderr.puts "Error: Could not read app info from '#{app_path}'"
        exit 1
      end

      app_name = app_info['CFBundleName'] || app_info['CFBundleDisplayName'] || File.basename(app_path, '.app')

      # Check if app is already in dock
      app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
      existing_index, existing_name = find_app_index(app_dicts, app_info['CFBundleIdentifier'])

      if existing_index
        $stderr.puts "Warning: '#{existing_name}' is already in the Dock, skipping"
        next
      end

      # Create the app tile
      app_tile = create_app_tile(app_path, app_info)

      if last_inserted_app_element
        apps_array.insert_after(last_inserted_app_element, app_tile)
        last_inserted_app_element = app_tile
      else
        apps_array.add(app_tile)
      end

      messages << "'#{app_name}' added to Dock."

    else
      # Search for app by name
      app_path = find_app_on_disk(item_query)
      unless app_path
        $stderr.puts "Error: App '#{item_query}' not found"
        exit 1
      end

      app_info = read_app_info(app_path)
      unless app_info && app_info['CFBundleIdentifier']
        $stderr.puts "Error: Could not read app info from '#{app_path}'"
        exit 1
      end

      app_name = app_info['CFBundleName'] || app_info['CFBundleDisplayName'] || File.basename(app_path, '.app')

      # Check if app is already in dock
      app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
      existing_index, existing_name = find_app_index(app_dicts, app_info['CFBundleIdentifier'])

      if existing_index
        $stderr.puts "Warning: '#{existing_name}' is already in the Dock, skipping"
        next
      end

      # Create the app tile
      app_tile = create_app_tile(app_path, app_info)

      if last_inserted_app_element
        apps_array.insert_after(last_inserted_app_element, app_tile)
        last_inserted_app_element = app_tile
      else
        apps_array.add(app_tile)
      end

      messages << "'#{app_name}' added to Dock."
    end
  end

  if messages.empty?
    $stderr.puts "No items were added to the Dock"
    exit 1
  end

  write_plist_and_restart(doc, messages)
end

# Remove app/folder subcommand
def cmd_remove(args)
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: dockedit remove <app_or_folder> [...]"
    opts.separator ""
    opts.separator "Examples:"
    opts.separator "  dockedit remove Safari Terminal"
    opts.separator "  dockedit remove ~/Downloads"
    opts.separator "  dockedit remove --help"
  end
  parser.order!(args)

  if args.empty?
    $stderr.puts parser
    exit 1
  end

  doc = load_dock_plist

  apps_array = get_persistent_apps(doc)
  others_array = get_persistent_others(doc)

  unless apps_array && others_array
    $stderr.puts "Error: Could not find dock arrays in plist"
    exit 1
  end

  messages = []

  # Process each argument
  args.each do |item_query|
    found = false

    # Determine if this looks like a path
    is_path = item_query.include?('/')

    # First check persistent-apps
    app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
    index, name = find_app_index(app_dicts, item_query)

    if index
      apps_array.delete(app_dicts[index])
      messages << "'#{name}' removed from Dock."
      found = true
    end

    # If not found in apps, check persistent-others (folders)
    unless found
      folder_dicts = others_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
      index, name = find_item_index(folder_dicts, item_query, check_url: is_path)

      if index
        others_array.delete(folder_dicts[index])
        messages << "'#{name}' removed from Dock."
        found = true
      end
    end

    unless found
      $stderr.puts "Warning: '#{item_query}' not found in Dock, skipping"
    end
  end

  if messages.empty?
    $stderr.puts "No items were removed from the Dock"
    exit 1
  end

  write_plist_and_restart(doc, messages)
end

# Move app subcommand
def cmd_move(args)

  # Accept either order: move --after TARGET ITEM or move ITEM --after TARGET
  options = { after: nil }
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: dockedit move --after <target> <item_to_move> OR dockedit move <item_to_move> --after <target>"
    opts.separator ""
    opts.separator "Examples:"
    opts.separator "  dockedit move --after Terminal Safari"
    opts.separator "  dockedit move Safari --after Terminal"
    opts.on('-a', '--after ITEM', 'Move after specified app/folder (required, fuzzy match)') { |app| options[:after] = app }
  end
  # Use permute! to allow flags before or after positional args
  parser.permute!(args)

  # Now, args should contain the non-option arguments (either [item] or [target, item] or [item, target])
  after_target = options[:after]

  # Accept either order: --after TARGET ITEM or ITEM --after TARGET
  item_query = nil
  if after_target && args.length == 1
    item_query = args.first
  elsif after_target && args.length == 2
    # Try to infer which is the item and which is the target
    if args[0].downcase == after_target.downcase
      item_query = args[1]
    elsif args[1].downcase == after_target.downcase
      item_query = args[0]
    else
      # Default: treat first as item
      item_query = args[0]
    end
  else
    $stderr.puts parser
    $stderr.puts "\nError: You must specify an item to move and a target with --after."
    exit 1
  end

  if !after_target || !item_query
    $stderr.puts parser
    $stderr.puts "\nError: You must specify an item to move and a target with --after."
    exit 1
  end

  doc = load_dock_plist

  apps_array = get_persistent_apps(doc)
  others_array = get_persistent_others(doc)

  unless apps_array && others_array
    $stderr.puts "Error: Could not find dock arrays in plist"
    exit 1
  end

  # Find the item to move (check apps first, then folders)
  move_element = nil
  move_name = nil
  move_array = nil

  app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
  move_index, move_name = find_app_index(app_dicts, item_query)

  if move_index
    move_element = app_dicts[move_index]
    move_array = apps_array
  else
    folder_dicts = others_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
    move_index, move_name = find_item_index(folder_dicts, item_query, check_url: true)

    if move_index
      move_element = folder_dicts[move_index]
      move_array = others_array
    end
  end

  unless move_element
    $stderr.puts "Error: '#{item_query}' not found in Dock"
    exit 1
  end

  # Find the target (check apps first, then folders)
  after_element = nil
  after_name = nil
  after_array = nil

  app_dicts = apps_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
  after_index, after_name = find_app_index(app_dicts, after_target)

  if after_index
    after_element = app_dicts[after_index]
    after_array = apps_array
  else
    folder_dicts = others_array.elements.to_a.select { |e| e.is_a?(REXML::Element) && e.name == 'dict' }
    after_index, after_name = find_item_index(folder_dicts, after_target, check_url: true)

    if after_index
      after_element = folder_dicts[after_index]
      after_array = others_array
    end
  end

  unless after_element
    $stderr.puts "Error: '#{after_target}' not found in Dock"
    exit 1
  end

  # Check if they're the same item
  if move_element == after_element
    $stderr.puts "Error: Cannot move an item after itself"
    exit 1
  end

  # Check if moving between arrays (apps <-> folders) - not allowed
  if move_array != after_array
    $stderr.puts "Error: Cannot move items between apps and folders sections"
    exit 1
  end

  # Remove from current position
  move_array.delete(move_element)

  # Insert after target
  move_array.insert_after(after_element, move_element)

  write_plist_and_restart(doc, "'#{move_name}' moved after '#{after_name}'.")
end

# Main entry point
def main
  global_parser = OptionParser.new do |opts|
    opts.banner = "Usage: dockedit <subcommand> [options] [args]"
    opts.separator ""
    opts.separator "Subcommands:"
    opts.separator "  add [-a|--after <item>] [--show-as TYPE] <item>...  Add app(s)/folder(s)"
    opts.separator "  move -a|--after <item> <item>                       Move an item after another"
    opts.separator "  remove <item>...                                    Remove app(s)/folder(s)"
    opts.separator "  space [-s|--small] [-a|--after <app>]               Insert space(s)"
    opts.separator ""
    opts.separator "Folder shortcuts: desktop, downloads, home, library, documents, applications, sites"
    opts.separator ""
    opts.separator "Examples:"
    opts.separator "  dockedit add Safari Terminal"
    opts.separator "  dockedit add ~/Downloads --show grid --display stack"
    opts.separator "  dockedit add Notes --after Safari"
    opts.separator "  dockedit space --small --after Safari"
    opts.separator "  dockedit move --after Terminal Safari"
    opts.separator "  dockedit move Safari --after Terminal"
    opts.separator ""
    opts.separator "Options:"
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      exit 0
    end
  end

  if ARGV.empty?
    puts global_parser
    exit 0
  end

  subcommand = ARGV.shift

  case subcommand
  when 'add'
    cmd_add(ARGV)
  when 'move'
    cmd_move(ARGV)
  when 'remove'
    cmd_remove(ARGV)
  when 'space'
    cmd_space(ARGV)
  when '-h', '--help'
    puts global_parser
    exit 0
  else
    $stderr.puts "Unknown subcommand: #{subcommand}"
    $stderr.puts "Run 'dockedit --help' for usage"
    exit 1
  end
end

main
